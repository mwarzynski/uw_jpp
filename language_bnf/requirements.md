Wymagania:
 1. Co najmniej dwa typy wartości w wyrażeniach: int i bool (to znaczy if 2+2 then _ parsuje się, ale wyrażenie ma niepoprawny typ).
 2. Arytmetyka, porównania.
 3. while, if (z else i bez, może być też składnia if _ elif _ else _ endif).
 4. Funkcje lub procedury (bez zagnieżdżania), rekurencja.
 5. Jawne wypisywanie wartości na wyjście (instrukcja lub wbudowana procedura print).
 6.  Dwie wybrane rzeczy z poniższej listy lub coś o porównywalnej trudności:
    a) dwa sposoby przekazywania parametrów (przez zmienną / przez wartość),
    b) pętla for w stylu Pascala,
    c) typ string, literały napisowe, wbudowane funkcje pozwalające na rzutowanie między napisami a liczbami,
    d) wyrażenia z efektami ubocznymi (przypisania, operatory języka C ++, += itd).

17 punktów:
 7. Statyczne typowanie (tj. zawsze terminująca faza kontroli typów przed rozpoczęciem wykonania
programu). (Wymaganie nie dotyczy nietrywialnych projektów, w których dynamiczne
typowanie jest istotną cechą wybranego języka, np. Smalltalk, JavaScript).

20 punktów:
 8. Przesłanianie identyfikatorów ze statycznym ich wiązaniem (np. zmienne globalne i lokalne w
funkcjach lub lokalne w blokach).
 9. Jawnie obsłużone dynamiczne błędy wykonania, np. dzielenie przez zero.
 10. Funkcje zwracające wartość (tzn. nie tylko procedury; za to mogą być tylko funkcje – jak w języku C).
 11. Dwie dodatkowe rzeczy z poniższej listy lub coś o porównywalnej trudności:
    a) rekordy,
    b) tablice indeksowane int lub coś à la listy,
    c) tablice/słowniki indeksowane dowolnymi porównywalnymi wartościami; typ klucza należy uwzględnić w typie słownika,
    d) dowolnie zagnieżdżone krotki z przypisaniem jak w Pythonie (składnia wedle uznania),
    e) operacje przerywające pętlę while - break i continue,
    f) funkcje jako parametry,
    g) zwracanie funkcji w wyniku, domknięcia à la JavaScript.
    h) funkcje anonimowe (szczególnie sensowne w połączeniu z punktem f).

24 punkty:
12. Dowolnie zagnieżdżone definicje funkcji / procedur z zachowaniem poprawności statycznego wiązania identyfikatorów (jak w Pascalu).
13. Jeszcze jedna-dwie funkcjonalności z listy powyżej.

